({emulatorVersion:1,code:";-------------------------------------------------------------------------\n; Port map\n;-------------------------------------------------------------------------\n;\n; Timing\n; 0x00 0x01 0x02 0x03 (LSB ... MSB) = current system time in ms (ports 0, 1, 2 and 3 are updated when port 0 is read) (RO)\n; 0x04 0x05 0x06 0x07 (LSB ... MSB) = timer interval in ms (used to start timers 0, 1, 2 and 3) (RW)\n; 0x08 = timer 0 on/off (0 stops the timer, while any other value either starts or restarts it) (RW)\n; 0x09 = timer 1 on/off (0 stops the timer, while any other value either starts or restarts it) (RW)\n; 0x0A = timer 2 on/off (0 stops the timer, while any other value either starts or restarts it) (RW)\n; 0x0B = timer 3 on/off (0 stops the timer, while any other value either starts or restarts it) (RW)\n;\n; Buttons and lighting\n; 0xE0 = number of the button which has been pressed/released (0 ... 15) (RO)\n; 0xE1 = current state of the toggled button (0 = released, 1 = pressed) (RO)\n; 0xE2 = light bulbs' state (bit 0 controls bulb 0 ...) (RW)\n;\n; EEPROM\n; 0xE3 = EEPROM address (by changing address, if OE = 1, data is updated with actual EEPROM's contents) (RW)\n; 0xE4 = EEPROM data (if OE = 1 writings are ignored) (RW)\n; 0xE5 = EEPROM control (RW)\n;        bit 0 = Not WR (by toggling from 1 to 0, data's contents is stored into the EEPROM)\n;        bit 1 = OE (OE = 1 makes data RO, while 0 makes it RW)\n;\n; Console\n; 0xE6 = general purpose value (RW)\n;\t\t - maximum amount of characters that the user is allowed to enter with command 1\n;\t\t - amount of characters to send to the console with command 3\n;\t\t - color component for commands 6 ... 11\n; 0xE7 = general purpose value (RW)\n;\t\t - row index for commands 5 ... 11\n; 0xE8 = control commands (RW)\n;\t\t 0 = hides the console input\n;\t\t 1 = shows the console input\n;\t\t 2 = clears the console's memory\n;\t\t 3 = sends the text pointed by 0xEC to console's memory (a 0 character stops the process, even if the value at 0xE6 is greater)\n;\t\t 4 = copies the contents of the console's memory to the screen\n;\t\t 5 = copies the contents of the given row, from the console's memory to the screen\n;\t\t 6, 7, 8 = specifies the R, G or B component for the given row's background color\n;\t\t 9, 10, 11 = specifies the R, G or B component for the given row's text color\n; 0xE9 = amount of characters typed by the user (this value is set to 0 by commands 0 and 1) (RO)\n; 0xEA = cursor's X position (0 ... 79) (RW)\n; 0xEB = cursor's Y position (0 ... 19 or 20, when Y = 20, the next character written to the screen causes it to scroll) (RW)\n; 0xEC 0xED 0xEE 0xEF (LSB ... MSB) = address where to fetch the text to be sent/to store the text typed by the user (RW)\n;\n; Reset\n; 0xFF = system reset (writing a value other than 0 resets the processor and finishes the execution) (WO)\n;\n;-------------------------------------------------------------------------\n; External interrupt map\n;-------------------------------------------------------------------------\n; 0x20 = timer 0\n; 0x21 = timer 1\n; 0x22 = timer 2\n; 0x23 = timer 3\n; 0x30 = buttons\n; 0x31 = console's input OK button\n;\n;-------------------------------------------------------------------------\n; Instructions for storing the context\n;-------------------------------------------------------------------------\n; XSAVE mem = stores the processor's state at the memory pointed to by mem (requires at least 36 bytes)\n; XRSTOR mem = loads the processor's state from the memory pointed to by mem (requires at least 36 bytes)\n; Instru\u00e7\u00e3o XSAVE stores the registers in the following order: EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP, FLAGS\n;-------------------------------------------------------------------------\n\n\t;--------------------------------------------------------------------------------\n\t;       ----  || NOTES ||  ----\n\t; * _atoi , _itoa , and _hex_to_char_ might need optimization\n\t; * work on actual command functions\n\t; * work on INT 32 and INT 47 and others\n\t;--------------------------------------------------------------------------------\n\t\n\tcli\n\tmov proc_id, 1\n\tmov eax, 0\n\tout 0x08, eax\n\t\n\tmov ebp, esp          ; initialize\n\tsub esp, 17900\n\tmov eax, esp          ; set up pointers\n\tadd eax, 4\n\tmov input_text, eax   ; point to input text\n\tadd eax, 256\n\tmov out_text, eax\n\tadd eax, 512\n\tmov dword ptr[command_args], eax ; point to command args (string tokens after split)\n\tmov edi, eax\n\tadd eax, 512\n\tmov commands, eax     ; point to list of commands\n\tmov ebx, eax\n\t\n\tmov dword ptr[eax], 0x00646461     ;add\\n\n\tmov dword ptr[eax+4], 0x00627573   ;sub\\n\n\tmov dword ptr[eax+8], 0x006c756d   ;mul\\n\n\tmov dword ptr[eax+12], 0x00766964  ;div\\n\n\tmov dword ptr[eax+16], 0x6f686365  ;echo\n\tmov byte ptr[eax+20], 0x00         ;\\n\n\t\n\tadd eax, 256                       ; 1280 item lookup table, 12 byte aligned\n\tmov lookup_table, eax              ; 8 byte id     4 byte address\n\t\n\t;add eax, 15360\n\t;push eax\n\t;mov word ptr[eax], 994\n\t;mov ebx, eax\n\t;add ebx, 6\n\t;mov dword ptr[eax+2], 0\n\t\n\tmov eax, 17000                      ; set up interrupt descriptor table\n\tmov ebx, eax\n\tpush eax\n\t;mov word ptr[eax], 1020            ; length - 1020\n\t;mov ebx, eax\n\t;add ebx, 6\n\t;mov dword ptr[eax+2], ebx          ; 1200 -> 2220\n\t\n\t\n\tadd eax, 128\n\tpush eax\n\tcall _set_ISrs_\n\tadd esp, 4\n\t;mov ebx, _irq_32\n\t;mov dword ptr[eax], ebx\n\t\n\tpop ebx\n\tlidt ebx\n\t\n\tmov eax, 0x00000001\n\tout 0x04, eax\n\tin eax, 0x04\n\t\n\tmov eax, 1\n\tout 0x08, eax\n\t\n\t; proccess table (110 bytes per entry)\n\t; struct proc_tab_entry{\n\t;\tbyte id;\n\t;\tuint32_t * ptr;\n\t;\tchar[64] name;\n\t;   byte[36] regs;         // at 69 bytes in\n\t;   uint32_t lastTicks;    // at 105 bytes in\n\t;   byte priority;\n\t;}\n\t\n\t; TODO : Continue work at Int 32\n\t\n\tlea eax, proc                   ; address of proccess list\n\tmov byte ptr[eax], 0x1          ; proc id 1 -> Kernel\n\t\n\t;int 34                          ;fetch mem chunk (2048 bytes)\t\n\t\n\tmov dword ptr[eax+1], _loop      ;addr of mem chunk\n\tmov dword ptr[eax+5], 0x4E52454B ; \"KERNEL\"\n\tmov dword ptr[eax+9], 0x00004C45\n\t\n\tmov dword ptr[eax+69], eax       ; save regs - for use in case of pre-emption\n\tmov dword ptr[eax+73], ebx\n\tmov dword ptr[eax+77], ecx\n\tmov dword ptr[eax+81], edx\n\tmov dword ptr[eax+85], esi\n\tmov dword ptr[eax+89], esi\n\tmov dword ptr[eax+93], ebp\n\tmov dword ptr[eax+97], esp\n\tmov dword ptr[eax+101], _loop\n\t\n\t\n\tadd eax, 105\n\tmov byte ptr[eax], 0x2          ; console id -> 2\n\t\n\tmov dword ptr[eax+1], check_commands\n\tmov dword ptr[eax+5], 0x534E4F43    ; \"CONSOLE\"\n\tmov dword ptr[eax+9], 0x00454C4F\n\t\n\tmov dword ptr[eax+69], eax       ; save regs - for use in case of pre-emption\n\tmov dword ptr[eax+73], ebx\n\tmov dword ptr[eax+77], ecx\n\tmov dword ptr[eax+81], edx\n\tmov dword ptr[eax+85], esi\n\tmov dword ptr[eax+89], esi\n\tmov dword ptr[eax+93], ebp\n\tmov dword ptr[eax+97], esp\n\tmov dword ptr[eax+101], check_commands\n\t\n\tin eax, 0x0\n\tsti\n\t;int 33\n\t\n\tmov eax, 0\n\tmov ecx, 128\n\t;rep stosd\n\t\n\tmov eax, input_text   ; address to store text input by user (256 bytes)\n\tout 0xEC, eax\n\tmov al, 1             ; allow input\n\tout 0xE8, al\n\t\n\t\n\t;start kernel\n\tlea eax, proc\n\tmovzx ebx, byte ptr[eax]\n\tmov proc_id, ebx\n\tmov ebx, dword ptr[eax+1]\n\tsti\n\tjmp ebx\n\t\ncheck_commands:\n\tpush ebp\n\tmov ebp, esp\n\tsub esp, 0x100\n\t\n\t;setup and format input string\n\tmov eax, 32\n\tpush eax\n\t\n\tlea eax, command_args\n\tpush eax\n\t\n\tmov eax, dword ptr[command_args]\n\tpush eax\n\t\n\tmov eax, input_text\n\tpush eax\n\tcall _formstring_\n\tcall _string_split\n\t\n\t;resume checking\n\t\n\tadd esp, 16\n\tlea eax, command_args\n\tpush eax\n\tcall get_argc\n\tadd esp, 4\n\tmov argc, al\n\t\n\tmov eax, dword ptr[command_args]\n\tpush eax\n\t\n\t;is it add?\n\tmov eax, commands\n\tpush eax\n\t\n\tcall _stringcmp\n\tadd esp, 4\n\ttest eax, eax\n\tjne _notadd\n\t\n\t;call add function here\n\tlea eax, command_args\n\tpush eax\n\t\n\tmovzx eax, argc\n\tpush eax\n\t\n\tcall _add\n\tpush eax\n\t\n\tpop ebx\n\tmov eax, out_text\n\tmov dword ptr[eax], ebx\n\tmov dword ptr[eax+4], 0x000000\n\tpush eax\n\t\n\tmov eax, ebx\n\t\n\tint 32                 ; for testing purposes\n\t\n\tcall _hex_to_char_\n\tcall _itoa\n\tcall _old_char_method_\n\tcall print_text\n\t\n\tmov eax, out_text\n\tadd eax, 512\n\t;repstosd here to flush out_text\n\tmov ebx, dword ptr[eax]\n\t\n\tcall _prnt_newline_\n\tcall _enable_input_\n\t\n_notadd:\n\t;is it sub?\n\tmov eax, commands\n\tadd eax, 4\n\tpush eax\n\t\n\tcall _stringcmp\n\tadd esp, 4\n\ttest eax, eax\n\tjne _notsub\n\t\n\t;call sub here\n\t\n\t\n_notsub:\n\t;is it mul?\n\tmov eax, commands\n\tadd eax, 8\n\tpush eax\n\t\n\tcall _stringcmp\n\tadd esp, 4\n\ttest eax, eax\n\tjne _notmul\n\t\n\t;call mul here\n\t\n\t\n_notmul:\n\t;is it div?\n\tmov eax, commands\n\tadd eax, 12\n\tpush eax\n\t\n\tcall _stringcmp\n\tadd esp, 4\n\ttest eax, eax\n\tjne _notdiv\n\t\n\t;call div here\n\t\n\t\n_notdiv:\n\t;is it echo?\n\tmov eax, commands\n\tadd eax, 16\n\tpush eax\n\t\n\tcall _stringcmp\n\tadd esp, 4\n\ttest eax, eax\n\tjne _pre_loop               ;change as you add more commands\n\t\n\t;call echo here\n\n_pre_loop:\n\tmov esp, ebp\n\tpop ebp\n\t\n\tcall _prnt_newline_\n\tcall _enable_input_\n\tret\n\n;----------------------------------------------------------------------------------------------------------------------------\n;        ||| MAIN LOOP, SHUTDOWN, AND MISC. |||\n;----------------------------------------------------------------------------------------------------------------------------\n\n_loop:\n\t;issue : INT 32 only called once\n\tcli\n\tsti\n\tjmp _loop\n\t\n\t\nSHUT_DOWN:\n\t; Sending any byte other than 0 to port 255 finishes the execution\n\tmov al, 1\n\tout 255, al\n\t\n_prnt_newline_:\n\tmov eax, 0\n\tout 0xEA, eax\n\tin al, 0xEB\n\tinc al\n\t\n\tmov al, yrow\n\tinc al\n\tinc yrow\n\tcmp al, 20\n\tjle nline\n\tmov yrow, 20\n\tmov al, 20\n\t\n\tnline:\n\tout 0xEB, al\n\tret\n\t\n_enable_input_:\n\t;sanitize input method to allow another user input\n\tmov edi, input_text\n\tmov eax, 0\n\tmov ecx, 64\n\trep stosd\n\t\n\tlea edi, command_args\n\tadd edi, 4\n\tmov ecx, 255\n\trep stosd\n\t\n\tmov eax, input_text\n\tout 0xEC, eax\n\tmov al, 1             ; re-allow input\n\tout 0xE8, al\n\t\n\tret\n\t\n;----------------------------------------------------------------------------------------------------------------------------\n;        ||| CHAR SND STRING FUNCTIONS |||\n;----------------------------------------------------------------------------------------------------------------------------\n\nprint_text:\n\tpush ebp\n\tmov ebp, esp\n\tsub esp, 0\n\t\n\tmov eax, dword ptr[ebp+8] ; thing to be printed\n\tout 0xEC, eax\n\tmov eax, 0x0300FF\n\tout 0xE6, eax\n\tmov al, 4 ; Update the entire screen at once\n\tout 0xE8, al\n\t\n\tcall _prnt_newline_\n\t\n\tmov esp, ebp\n\tpop ebp\n\tret\n\t\n_formstring_:\n;make input correct ascii\n\tpush ebp\n\tmov ebp, esp\n\tsub esp, 0\n\t\n\tmov ecx, dword ptr[ebp+8]      ;get user input\n\tmov dl, 0\n\tmov dh, 0\n\tf_loop:\n\tmov al, byte ptr[ecx+dl]\n\tmov byte ptr[ecx+dh], al\n\tadd dl, 2\n\tinc dh\n\ttest al, al\n\tjne f_loop\n\t\n\tmov esp, ebp\n\tpop ebp\n\tret\n\n_stringcmp:\n;check against command list\n\tpush ebp                       ;save context\n\tmov ebp, esp\n\tsub esp, 0\n\t\n\txor ebx, ebx\n\tmov ecx, dword ptr[ebp+8]      ;get user input\n\tmov esi, dword ptr[ebp+12]\n\tmov edx, 0\n\tmloop:\n\tmov al, byte ptr[ecx+edx]\n\tmov bl, byte ptr[esi+edx]\n\tinc edx\n\tcmp al, bl\n\tjne anal_string_end\n\t\n\ttest ebx, ebx                ;test if null char\n\tjne mloop\n\txor eax, eax\n\tmov esp, ebp\n\tpop ebp\n\tret\n\t\n\tanal_string_end:\n\tmov eax, 1\n\tmov esp, ebp\n\tpop ebp                        ;restore context\n\tret\n\t\n_old_char_method_:\n;convert to char with all null separated characters\n;use before printing to screen\n\tpush ebp\n\tmov ebp, esp\n\tsub esp, 0\n\t\n\tmov ecx, dword ptr[ebp+8]     ;pointer to char* array\n\tmov bl, 0\n\tmov bh, 0\n\t\n\txor edx, edx                  ;force zeroing of edx\n\toldchar_loop:\n\tmov dl, byte ptr[ecx+bh]      ;get current char\n\tpush edx                      ;push onto stack\n\tinc bh                        ;inc bh\n\ttest dl, dl\n\tjne oldchar_loop              ;if not null char, continue\n\t\n\txor edx, edx                  ;force zeroing of edx\n\toldchar_loop_two:\n\tdec bh                        ;dec bh\n\tmov bl, bh                    ;bl = bh * 2\n\tadd bl, bh\n\tpop edx                       ;pop off stack\n\tmov byte ptr[ecx+bl], dl      ;move dl to current byte\n\tdec bl                        ;dec bl\n\tmov byte ptr[ecx+bl], 0       ;move $00 to current byte - 1\n\ttest bh, bh                   ;test for zero\n\tjne oldchar_loop_two\n\t\n\tmov esp, ebp\n\tpop ebp\n\tret\n\t\n_string_split:\n\t; _string_split(char* str, int* strt_addr, int*[] token_addrs, char spltr);\n\tpush ebp\n\tmov ebp, esp\n\tsub esp, 0\n\t\n\txor edx, edx\n\txor eax, eax\n\txor ebx, ebx\n\tmov ecx, dword ptr[ebp+8]   ; get string\n\tmov esi, dword ptr[ebp+12]  ; get target address\n\tmov edi, dword ptr[ebp+16]  ; get char array to store token addresses\n\tmov bl, byte ptr[ebp+20]    ; get char to split on\n\txor edx, edx                ; counter (dh) and last split position (dl)\n\tmfloop:\n\tmov al, byte ptr[ecx+dh]\n\tinc dh\n\tcmp al, 0\n\tje pre_recur_ssplt\n\tcmp al, bl\n\tjne mfloop\n\t\n\tpre_recur_ssplt:\n\tmov ah, dh\n\tdec dh\n\t\n\trecur_ssplit:\n\tdec dh\n\tmov al, byte ptr[ecx+bh]\n\tmov byte ptr[esi+bh], al\n\tinc bh\n\tcmp dh, dl\n\tjne recur_ssplit\n\t\n\tmov byte ptr[esi+bh], 0     ; write null terminator\n\tinc bh\n\t\n\tmov dh, ah\n\tmov dl, ah          ;check for null or 256th char overflow\n\t\n\tcmp dh, 256\n\tje end_ssplt\n\tdec dh\n\tcmp byte ptr[ecx+dh], 0\n\tje end_ssplt\n\tinc dh\n\t\n\tadd edi, 4\n\tlea eax, [esi+bh]\n\tmov dword ptr[edi], eax\n\t\n\tjmp mfloop\n\t\n\tend_ssplt:\n\tmov esp, ebp\n\tpop ebp\n\tret\n\t\nget_argc:\n\tpush ebp\n\tmov ebp, esp\n\tsub esp, 0\n\txor edx, edx\n\t\n\targc_mloop:\n\tinc dl\n\tmov eax, dword ptr[ebp+8] ;get *argv[] address\n\tmov ebx, dword ptr[eax+dh]\n\tadd dh, 4\n\tcmp ebx, 0\n\tjne argc_mloop\n\t\n\tdec dl\n\tmov al, dl ; return argc\n\t\n\tmov esp, ebp\n\tpop ebp\n\tret\n\t\n_atoi:\n\tpush ebp\n\tmov ebp, esp\n\tsub esp, 0\n\t\n\tmov ebx, dword ptr[ebp+8] ; get address of *char[]\n\txor ecx, ecx              ; cl = byte, ch = counter\n\tmov eax, 1\n\tmov edx, 1                ; edx = multiplicand\n\txor edi, edi              ; edi stores new int\n\txor esi, esi              ; esi stores old int\n\t\n\tpre_atoi_loop:\n\tmov cl, [ebx+ch]\n\tdec ch\n\tcmp cl, 0\n\tje atoi_mloop\n\tadd ch, 2\n\tjmp pre_atoi_loop\n\t\n\tatoi_mloop:\n\tmov cl, [ebx+ch]\n\tcmp cl, 0\n\tje atoi_end\n\t\n\t; begin actual conversion\n\tsub cl, 0x30\n\tmovzx edi, cl\n\tpush eax\n\tmul edi\n\tadd esi, eax\n\t\n\tdec ch\n\tmov eax, 10\n\tpop edx\n\tmul edx\n\tmov edx, eax\n\t\n\tjmp atoi_mloop\n\t\n\tatoi_end:\n\tmov eax, esi\n\t\n\tmov esp, ebp\n\tpop ebp\n\tret\n\t\n_itoa:\n\tpush ebp\n\tmov ebp, esp\n\t\n\tmov ebx, dword ptr[ebp+8]  ; get *char[]\n\txor ecx, ecx\n\t\n\titoa_mloop:\n\tmov cl, byte ptr[ebx+ch]\n\tadd cl, 0x30\n\tmov byte ptr[ebx+ch], cl\n\tinc ch\n\tcmp ch, 5\n\tjne itoa_mloop\n\t\n\tmov esp, ebp\n\tpop ebp\n\tret\n\n_hex_to_char_:\n\t;convert hex to decimal, mostly used before hex-to-ascii conversions\n\tpush ebp\n\tmov ebp, esp\n\t\n\tmov ebx, dword ptr[ebp+8] ; eax contains value already, ebx contains address to print chars in decimal\n\txor edx, edx              ; remainder\n\txor edi, edi              ; counter\n\txor ecx, ecx              ; divisor\n\tmov ecx, 10\n\t\n    mov esi, eax                  ; save eax\n\t\n\tless_than_hundred:\n\tmov eax, esi\n\tcmp eax, 10\n\tjl less_than_ten\n\tmov ecx, 10\n\tdiv ecx\n\t\n\tmov byte ptr[ebx+edi], al  ; save tens\n\tinc edi\n\t\n\tmov eax, edx                ; save rem (ones left over)\n\tmov esi, eax\n\t\n\t\n\tless_than_ten:\n\tmov byte ptr[ebx+edi], al  ; save ones\n\tinc edi\n\t\n\t\n\tend_htch_:\n\tmov esp, ebp\n\tpop ebp\n\tret\n\n;----------------------------------------------------------------------------------------------------------------------------\n;        ||| GENERAL PROMPT COMMANDS |||\n;----------------------------------------------------------------------------------------------------------------------------\n\n_add:\n\tpush ebp\n\tmov ebp, esp\n\tsub esp, 4\n\t\n\t;code here\n\tmov eax, dword ptr[ebp+8]  ; get argc\n\tdec eax\n\tmov ebx, dword ptr[ebp+12] ; get *argv[]\n\txor ecx, ecx\n\txor edx, edx\n\t\n\tsub ebp, 4\n\tmov dword ptr[ebp], 0\n\t\n\tcmp eax, 0\n\tje add_help_sec\n\t\n\tadd_mloop:\n\tdec eax\n\tadd cl, 4\n\t\n\t;convert byte to int\n\tmov esi, [ebx+cl] ; check here\n\t\n\t;save registers\n\tpush eax\n\tpush ebx\n\tpush ecx\n\tpush edi\n\tpush esi\n\t\n\tcall _atoi  ;work here\n\t\n\tmov edx, eax ; int ends up in edx\n\tmov eax, [ebp]\n\t\n\t;restore registers\n\tpop esi\n\tpop edi\n\tpop ecx\n\tpop ebx\n\tpop eax\n\t\n\tadd dword ptr[ebp], edx  ; sum = sum + newNumber\n\t\n\t;add edx, dword ptr[ebx+cl]  // might need\n\tcmp eax, 0\n\tjne add_mloop\n\t\n\tmov eax, dword ptr[ebp]  ; sum is stored in eax\n\t\n\tadd ebp, 4\n\tmov esp, ebp\n\tpop ebp\n\tret\n\t\n\tadd_help_sec:\n\t\n\n_sub:\n\tpush ebp\n\tmov ebp, esp\n\tsub ebp, 0\n\t\n\t;code here\n\t\n\tmov esp, ebp\n\tpop ebp\n\tret\n\n_mul:\n\tpush ebp\n\tmov ebp, esp\n\tsub ebp, 0\n\t\n\t;code here\n\t\n\tmov esp, ebp\n\tpop ebp\n\tret\n\n_div:\n\tpush ebp\n\tmov ebp, esp\n\tsub ebp, 0\n\t\n\t;code here\n\t\n\tmov esp, ebp\n\tpop ebp\n\tret\n\n_echo:\n\tpush ebp\n\tmov ebp, esp\n\tsub ebp, 0\n\t\n\t;code here\n\t\n\tmov esp, ebp\n\tpop ebp\n\tret\n\n;------------------------------------------------------------------------------------------------------------------------------------------------\n;------------------------------------------------------------------------------------------------------------------------------------------------\n;******************************* INTERRUPT HANDLING *********************************************************************************************\n;------------------------------------------------------------------------------------------------------------------------------------------------\n;                       MAP\n;        32.  Timer 0  (sys clock)   33.  Timer 1  (watchdog)      34.Timer 2(User Timer) 35.  Timer 3 (Shutdown clock)  36.\n;        37.                         38.                           39.\n;        40.                         41.                           42.                    43                     44.\n;        45.                         46.                           47. Shutdown           48.  Button sig        49. Console Input\n\n_set_ISrs_:\n\tpush ebp\n\tmov ebp, esp\n\tsub esp, 0\n\t\n\tmov eax, [ebp+8]         ; set eax to Int 32 IDT address\n\t\n\tmov ebx, _irq_32\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_33\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_34\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_35\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_36\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_37\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_38\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_39\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_40\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_41\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_42\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_43\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_44\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_45\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_46\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_47\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_48\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_49\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_50\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_51\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_52\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_53\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_54\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_55\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_56\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_57\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_58\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_59\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_60\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_61\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_62\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_63\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_64\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_65\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_66\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_67\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_68\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_69\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_70\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_71\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_72\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_73\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_74\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\tmov ebx, _irq_75\n\tmov dword ptr[eax], ebx\n\tadd eax, 4\n\t\n\t\n\tmov esp, ebp\n\tpop ebp\n\tret\n\n_irq_32:\n\t; pre-emption\n\t; scheduler\n\t; Timing\n\t; 0x00 0x01 0x02 0x03 (LSB ... MSB) = current system time in ms (ports 0, 1, 2 and 3 are updated when port 0 is read) (RO)\n\t; 0x04 0x05 0x06 0x07 (LSB ... MSB) = timer interval in ms (used to start timers 0, 1, 2 and 3) (RW)\n\t; 0x08 = timer 0 on/off (0 stops the timer, while any other value either starts or restarts it) (RW)\n\t; 0x09 = timer 1 on/off (0 stops the timer, while any other value either starts or restarts it) (RW)\n\t; 0x0A = timer 2 on/off (0 stops the timer, while any other value either starts or restarts it) (RW)\n\t; 0x0B = timer 3 on/off (0 stops the timer, while any other value either starts or restarts it) (RW)\n\t\n\tcli\n\tpush esp\n\tpush ebp\n\tpush edi\n\tpush esi\n\tpush edx\n\tpush ecx\n\tpush ebx\n\tpush eax\n\t\n\tmov eax, timer_ticks\n\tadd eax, 1\n\tmov timer_ticks, eax\n\t\n\tmov eax, proc_id\n\tmov ebx, 110\n\tmul ebx\n\tlea ebx, proc\n\tadd eax, ebx\n\t\n\tpop ebx\n\tmov dword ptr[eax+69], ebx\n\tpop ebx\n\tmov dword ptr[eax+73], ebx\n\tpop ebx\n\tmov dword ptr[eax+77], ebx\n\tpop ebx\n\tmov dword ptr[eax+81], ebx\n\tpop ebx\n\tmov dword ptr[eax+85], ebx\n\tpop ebx\n\tmov dword ptr[eax+89], ebx\n\tpop ebx\n\tmov dword ptr[eax+93], ebx\n\tpop ebx\n\tmov dword ptr[eax+97], ebx\n\tpop ebx\n\tmov dword ptr[eax+101], ebx\n\t\n\t;scheduler\n\tlea eax, proc                        ; find process list\n\t\n\tmov eax, proc_id\n\tmov ebx, 110\n\tmul ebx\n\tlea ebx, proc\n\tadd eax, ebx\n\tmov ebx, dword ptr[eax+101]\n\tmov temp, ebx\n\t\n\txrstor [eax+69]\n\tadd esp, 8\n\tsti\n\tjmp temp\n\t\n\tiret  ;should not need to get here. if we do, PANIC!\n\n_irq_33:\n    ; return ecx -> id\n\t; ebx contains limit\n\t\n\tcli\n\tpush esi\n\tpush edi\n\tpush ebp\n\t\n\txor ecx, ecx    ;condition of address\n\t\n\tirq33loop:\n\txor esi, edi\n\txor esi, eax\n\txor esi, ebx\n\tsub esi, eax\n\tsub esi, ebx\n\tmov edi, dword ptr[esp]\n\tcmp esi, ebx\n\tjg irq33loop\n\t\n\tmov ecx, esi\n\t\n\tpop ebp\n\tpop edi\n\tpop esi\n\tsti\n\tiret\n\n_irq_34:\n\t\n\tiret\n\n_irq_35:\n\t\n\tiret\n\n_irq_36:\n\t\n\tiret\n\n_irq_37:\n\t\n\tiret\n\n_irq_38:\n\t\n\tiret\n\n_irq_39:\n\t\n\tiret\n\n_irq_40:\n\t\n\tiret\n\n_irq_41:\n\t\n\tiret\n\n_irq_42:\n\t\n\tiret\n\n_irq_43:\n\t\n\tiret\n\n_irq_44:\n\t\n\tiret\n\n_irq_45:\n\t\n\tiret\n\n_irq_46:\n\t\n\tiret\n\n_irq_47:\n\t;Shutdown / Power / Sleep\n\t; al : 00000001 [0x1] --> Shutdown Now,  00000011 [0x3] --> shutdown after EBX seconds,  00000111 [0x7] --> Sleep Now,  00001111 [0xf] --> Sleep after EBX seconds\n\t; ah : bit0 -> Alert Messages?\n\tcli\n\tcmp al, 0x1\n\tjne _not_plainshutdown\n\t\n\t\n\t_not_plainshutdown:\n\tcmp al, 0x3\n\tjne _sleep\n\t;continue here. stopgap for now\n\tmov al, 1\n\tout 0xff, al\n\tiret\n\t\n\t_sleep:\n\t\n\t\n\tiret\n\n_irq_48:\n\t;Button Signal Interupt\n\t;Timing\n\t; 0x00 0x01 0x02 0x03 (LSB ... MSB) = current system time in ms (ports 0, 1, 2 and 3 are updated when port 0 is read) (RO)\n\t; 0x04 0x05 0x06 0x07 (LSB ... MSB) = timer interval in ms (used to start timers 0, 1, 2 and 3) (RW)\n\t; 0x08 = timer 0 on/off (0 stops the timer, while any other value either starts or restarts it) (RW)\n\t; 0x09 = timer 1 on/off (0 stops the timer, while any other value either starts or restarts it) (RW)\n\t; 0x0A = timer 2 on/off (0 stops the timer, while any other value either starts or restarts it) (RW)\n\t; 0x0B = timer 3 on/off (0 stops the timer, while any other value either starts or restarts it) (RW)\n\t;\n\t; Buttons and lighting\n\t; 0xE0 = number of the button which has been pressed/released (0 ... 15) (RO)\n\t; 0xE1 = current state of the toggled button (0 = released, 1 = pressed) (RO)\n\t; 0xE2 = light bulbs' state (bit 0 controls bulb 0 ...) (RW)\n\t;\n\t; Map : \n\t;\t0 ... Shutdown / Power / Sleep\n\t;   1 ... CLR Screen\n\t;   2 ... User Timer Reset\n\t;   3 ... User Timer Print Time (hh:mm:ss) [or just seconds?]\n\n\tcli\n\tpush ebp\n\tpush eax\n\tpush ebx\n\tpush ecx\n\tpush edx\n\tpush esi\n\tpush edi\n\t\n\t;work here\n\tmov ax, 0\n\tin al, 0xE0\n\tpush ax\n\t\n\tin al, 0xE1\n\tpush ax\n\t\n\tin al, 0xE2\n\tmov bl, al\n\t\n\tpop cx\n\tpop ax\n\tmov ah, ch\n\t\n\tcmp al, 0x00\n\tjne _not_shutdown\n\tmov al, 0x3\n\tmov ah, 0x1\n\tmov ebx, 0x5       ;shutdown after 5 seconds with alert flag set\n\tint 47\n\t\n\tpop edi\n\tpop esi\n\tpop edx\n\tpop ecx\n\tpop ebx\n\tpop eax\n\tpop ebp\n\tsti\n\t;call sanitation for pre-shutdown?\n\tiret\n\t\n\t_not_shutdown:\n\tcmp al, 0x01\n\tjne _not_clrscreen\n\t\n\tpop edi\n\tpop esi\n\tpop edx\n\tpop ecx\n\tpop ebx\n\tpop eax\n\tpop ebp\n\tsti\n\tjmp _loop\n\tiret\n\t\n\t_not_clrscreen:\n\tcmp al, 0x02\n\tjne _not_usertimer_reset\n\tmov al, 1000\n\tout 0x06, al\n\tmov al, 1\n\tout 0x0a, al ;reset timer 2 (User Timer with 1000 millisecond interval)\n\t\n\tpop edi\n\tpop esi\n\tpop edx\n\tpop ecx\n\tpop ebx\n\tpop eax\n\tpop ebp\n\tsti\n\tiret\n\t\n\t_not_usertimer_reset:\n\tcmp al, 0x03\n\tjne _not_usertimer_print\n\t;print timer count\n\t\n\tsti\n\tiret\n\t\n\t_not_usertimer_print:\n\t\n\t\n\t;if not handled, PANIC and stop execution\n\t;mov al, 1\n\t;out 0xff, al\n\t\n\tpop edi\n\tpop esi\n\tpop edx\n\tpop ecx\n\tpop ebx\n\tpop eax\n\tpop ebp\n\tsti\n\tiret\n\n_irq_49:\n\tcli\n\tpush ebp\n\tpush eax\n\tpush ebx\n\tpush ecx\n\tpush edx\n\tpush esi\n\tpush edi\n\t\n\tmov eax, input_text\n\tpush eax\n\tcall print_text\n\tadd esp, 4\n\tmov proc_id, 2\n\tsti\n\t\n\tcall check_commands\n\t\n\tcli\n\tmov proc_id, 1\n\tpop edi\n\tpop esi\n\tpop edx\n\tpop ecx\n\tpop ebx\n\tpop eax\n\tpop ebp\n\tsti\n\tiret\n\n_irq_50:\n\t\n\tiret\n\n_irq_51:\n\t\n\tiret\n\n_irq_52:\n\t\n\tiret\n\n_irq_53:\n\t\n\tiret\n\n_irq_54:\n\t\n\tiret\n\n_irq_55:\n\t\n\tiret\n\n_irq_56:\n\t\n\tiret\n\n_irq_57:\n\t\n\tiret\n\n_irq_58:\n\t\n\tiret\n\n_irq_59:\n\t\n\tiret\n\n_irq_60:\n\t\n\tiret\n\n_irq_61:\n\t\n\tiret\n\n_irq_62:\n\t\n\tiret\n\n_irq_63:\n\t\n\tiret\n\n_irq_64:\n\t\n\tiret\n\n_irq_65:\n\t\n\tiret\n\n_irq_66:\n\t\n\tiret\n\n_irq_67:\n\t\n\tiret\n\n_irq_68:\n\t\n\tiret\n\n_irq_69:\n\t\n\tiret\n\n_irq_70:\n\t\n\tiret\n\n_irq_71:\n\t\n\tiret\n\n_irq_72:\n\t\n\tiret\n\n_irq_73:\n\t\n\tiret\n\n_irq_74:\n\t\n\tiret\n\n_irq_75:\n\t\n\tiret\n",variables:[{name:"proc",size:1100,forceArray:true},{name:"proc_id",size:4,initialContents:1},{name:"temp",size:4,initialContents:0},{name:"yrow",size:1,initialContents:0},{name:"command_args",size:1024,forceArray:true},{name:"lookup_table",size:4,initialContents:0},{name:"info2",size:162,initialContents:"                              Feature demonstration                             "},{name:"info",size:410,initialContents:"Choose one test:\n\n\t1 - Timer, interrupts and lighting test\n\t2 - Buttons and lighting test (0 finishes the test)\n\t3 - Random lighting test (0 finishes, 1 pauses the test)\n\n\n*** Use the hardware buttons ***"},{name:"IDT",size:256,forceArray:true},{name:"commands",size:4},{name:"input_text",size:4},{name:"argc",size:1,initialContents:0},{name:"out_text",size:4,initialContents:0},{name:"timer_ticks",size:4,initialContents:0}],eeprom:[]})